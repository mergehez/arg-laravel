<?php

/** @noinspection PhpMultipleClassDeclarationsInspection */

namespace Arg\Laravel\Commands;

use Arg\Laravel\Enums\ArgBaseEnum;
use Illuminate\Console\Command;
use Illuminate\Support\Arr;
use UnitEnum;

abstract class ArgTransformer extends Command
{
    protected $signature = 'arg:transform {--force}';

    protected $description = 'Command description';

    protected string $sourceDirectory = 'lang';

    protected string $sourceExt = 'json';

    protected ?string $targetPhpDirectory = 'public/lang';

    abstract public function getDisplayLangKeys(): array;

    abstract protected function handle(): void;

    // private int $time = 0;

    /**
     * @param  array<EnumDef>  $enums
     */
    public function _handle(array $enums): void
    {
        $success = true;
        // $this->time = time();
        // $targetDir = 'public/lang';
        // $success = (new TranslationConverter(
        //     cmd: $this,
        //     targetPhpDirectory: $this->targetPhpDirectory,
        //     sourceDirectory: $this->sourceDirectory,
        //     sourceExt: $this->sourceExt
        // ))->convert();

        $contents = [];
        foreach ($enums as $enum) {
            $contents[] = $this->assocToEnum($enum->arr, $enum->enumName, $enum->typeName, $enum->pretty, $enum->asObject);
        }
        $contents = "// This file is auto-generated by ArgTransformer. Do not edit it manually!\n\n".implode("\n", $contents);
        $success = $success && file_put_contents('resources/js/Models/generated_enums.ts', $contents);

        if ($success) {
            $this->info(' -> Localization: (Re)converted json to php files.');
        } else {
            $this->error(' -> Localization: Conversion failed.');
        }
    }

    protected function assocToEnum($arr, $enumName, $typeName, $pretty = false, $asObject = false): string
    {
        $res = $this->enumToJsObject($arr, $pretty, $asObject);
        $res = $asObject ? "export const $enumName = $res as const;" : "export enum $enumName $res";
        if ($typeName) {
            $res .= "\nexport type T$typeName = keyof typeof $enumName;";
        }

        return $res;
    }

    private function enumToJsObject($arr, $pretty, $asObject, $depth = 0): string
    {
        $res = [];
        foreach ($arr as $k => $v) {
            $sep = $asObject ? ':' : ' =';

            if ($asObject && str_contains($k, '-')) {
                $k = "'$k'";
            }

            if (is_array($v)) {
                if (!Arr::isAssoc($v)) {
                    $res[] = "$k$sep ".json_encode($v).',';
                } else {
                    $v = $this->enumToJsObject($v, $pretty, $asObject, $depth + 1);
                    $res[] = "$k$sep $v,";
                }
            } else {
                if ($v instanceof UnitEnum) {
                    $k = $v->name;
                    $v = $v->value;
                }
                if (!$asObject && is_int($k)) {
                    $k = "_$k";
                }

                if (is_int($v)) {
                    $res[] = "$k$sep $v,";
                } elseif (str_contains($v, "'")) {
                    $res[] = "$k$sep \"$v\",";
                } else {
                    $res[] = "$k$sep '$v',";
                }
            }
        }
        if ($pretty) {
            $tabs = str_repeat("\t", $depth);
            $res = $tabs.implode("\n\t".$tabs, $res);
        } else {
            $tabs = '';
            $res = implode(' ', $res);
        }

        return "{\n\t$res\n$tabs}";
    }
}

readonly class EnumDef
{
    public function __construct(
        public array $arr,
        public string $enumName,
        public ?string $typeName,
        public bool $pretty = false,
        public bool $asObject = false
    ) {
    }

    /**
     * @param  class-string|ArgBaseEnum  $class
     * @return EnumDef
     */
    public static function fromBaseEnum($class, bool $asObject = false)
    {
        return new EnumDef($class::getAll(), last(explode('\\', $class)), null, true, $asObject);
    }
}
